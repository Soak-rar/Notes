### 如何创建GameMode

### 在c++中的中文字符串 UE编辑器中显示乱码
```
使用TEXT()宏创建字符串
```
#

### (```C++```)在自定义```GameMode```:```UMGPracticeGameMode```中将UI控件输出到视口(```viewport```)
将```World```的默认```GameMode```设置为```UMGPracticeGameMode```
![](./笔记img/设置GameMode.png)

分别在```UMGPracticeGameMode```的```.h```和```.cpp```文件中添加以下代码：
```C++
// .h
public:
    /** 移除当前菜单控件，并在指定类（如有）中新建控件。*/
    UFUNCTION(BlueprintCallable, Category = "UMG Game")
    void ChangeMenuWidget(TSubclassOf<UUserWidget> NewWidgetClass);

protected:
    /** 游戏开始时调用。*/
    virtual void BeginPlay() override;

    /** 游戏开始时，用作菜单的控件类。*/
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "UMG Game")
    TSubclassOf<UUserWidget> StartingWidgetClass;

    /** 用作菜单的控件实例。*/
    UPROPERTY()
    UUserWidget* CurrentWidget;
```

```C++
// .cpp

#include "HowTo_UMG.h"
#include "HowTo_UMGGameMode.h"

void AHowTo_UMGGameMode::BeginPlay()
{
    Super::BeginPlay();
    ChangeMenuWidget(StartingWidgetClass);
}

void AHowTo_UMGGameMode::ChangeMenuWidget(TSubclassOf<UUserWidget> NewWidgetClass)
{
    if (CurrentWidget != nullptr)
    {
        CurrentWidget->RemoveFromViewport();
        CurrentWidget = nullptr;
    }
    if (NewWidgetClass != nullptr)
    {
        CurrentWidget = CreateWidget<UUserWidget>(GetWorld(), NewWidgetClass);
        if (CurrentWidget != nullptr)
        {
            CurrentWidget->AddToViewport();
        }
    }
}
```

### 绑定输入按键
#### 注：同一场景的AActor可以设置同一个Controller，多个AActor可以同时响应同一个按键（在BindAction().bConsumeInput=false将输入消耗设为否）
1. 通过蓝图直接创建对应的事件处理节点
2. 通过```APawn```类或其子类，在 ```SetupPlayerInputComonent()```中，将对应的按键与按键触发的自定义处理函数绑定(绑定的系统按键可以在项目设置的input中设置)。
   ```C++
   void AKeyBoardCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
    {
        Super::SetupPlayerInputComponent(PlayerInputComponent);
        PlayerInputComponent->BindAction("KeyUp", IE_Pressed, this, &AKeyBoardCharacter::KeyUp);
        PlayerInputComponent->BindAction("KeyDown", IE_Pressed,this, &AKeyBoardCharacter::KeyDown); 
    }

    void AKeyBoardCharacter::KeyDown()
    {
        number = number > 0 ? (number - 1) : number;
        UE_LOG(LogTemp, Warning, TEXT("Down"));
    }

    void AKeyBoardCharacter::KeyUp()
    {
        number = number < 9 ? (number + 1) : number;
    }
    ```
3. 对于一般的AActor类，也实现了对输入的响应，在AActor的类中设置```InputComponent()```绑定按键与要触发的自定义函数（一般的AActor并不是默认响应输入的，需要绑定当前的Controller）（同样需要在项目设置中的input中添加操作映射）
    ```C++
    void AClickTestActor::BeginPlay()
    {
        Super::BeginPlay();
        //获取PlayerController
        APlayerController* PlayerController = UGameplayStatics::GetPlayerController(GWorld, 0);
        if (PlayerController!=nullptr)
        {
            //传入Playercontroller开启Input
            EnableInput(PlayerController);
            //绑定按键方法
            InputComponent->BindAction("W", IE_Pressed, this, &AClickTestActor::ClickFunc);
        }
    }

    void AClickTestActor::ClickFunc()
    {
        UE_LOG(LogTemp, Warning, TEXT("Click W"));
    }

    ```

### 什么是UMG。
虚幻示意图形界面设计器（Unreal Motion Graphics UI Designer）(UMG) 是一个可视化的UI创作工具，可以用来创建UI元素，如游戏中的HUD、菜单或您希望呈现给用户的其他界面相关图形。UMG的核心是控件，这些控件是一系列预先制作的函数，可用于构建界面（如按钮、复选框、滑块、进度条等）。这些控件在专门的控件蓝图中编辑，该蓝图使用两个选项卡进行构造：设计器（Designer）选项卡允许界面和基本函数的可视化布局，而图表（Graph）选项卡提供所使用控件背后的功能。


### 关于更换Visual studio版本问题
更换```Visual studio```版本后，直接使用ue或项目部文件启动会出现不兼容的情况，需要在UE编辑器中的编辑栏->编辑器偏好设置->通用->源代码 中将启动项改为对应版本

### 插件加载
在新建项目中，在项目文件夹（如项目```UMGProject```）下，创建```Plugins```文件夹，将对应插件文件夹复制到```Plugins```中，打开UE，在文件->刷新VS项目后，打开VS项目，关闭UE，VS中重新编译项目后，执行不调试。

### 插件添加子模块
在[ProjectName]->Plugins->[PluginName]->Source中
![](./笔记img/PluginSub.png)
创建```MyPluginSub```新模块对应的文件夹，并初始化内容
![](./笔记img/PluginSub_1.png)
初始化内容```MyPluginSub.Build.cs```文件、```Private```中的```MyPluginSub.cpp```和```Public```中的```MyPluginSub.h```文件。
（可以复制MyPlugin模块的对应文件，并替换内容实现初始化。或者新建项目中创建一个插件，复制对应的文件即可）
初始化结束后，重新生成项目
![](./笔记img/PluginSub_2.png)
引擎版本在首次生成时使用，删除对应的```Intermediate```文件夹和.sln文件，再生成VS项目文件。


### 设置容器的可视性(按钮控制下拉列表是否可见)
![](./笔记img/DropDownList.png)
![](./笔记img/DropDownList_1.png)
控制对应的容器面板```MaterialList```的隐藏与显示
```C++
void UAttributesui::ShowMaterialPanel()
{
	
	if (MaterialList)
	{
		if (MaterialList->GetVisibility() == ESlateVisibility::Hidden)
		{
			ShowTriangleBtn(EParameListTye::E_MATERIAL, EParameListState::E_SHOW);
			MaterialList->SetVisibility(ESlateVisibility::SelfHitTestInvisible);
		}
		else
		{
			ShowTriangleBtn(EParameListTye::E_MATERIAL, EParameListState::E_HIDE);
			MaterialList->SetVisibility(ESlateVisibility::Hidden);
		}
	}
}
```

### ```C++```中创建控件蓝图实例和获取控件蓝图中的现有控件
#### 创建控件蓝图，编辑器中获取蓝图的引用
![](./笔记img/CreateBPWidget.png)
```C++
uiPath = TEXT("Blueprint \'/DelysiumWeaponEditor/Editor_UI/Blueprints/UI_Material_panel.UI_Material_panel_C\'");
MaterialTextureUiClass = LoadClass<UUserWidget>(nullptr, *uiPath);
NewWidget = CreateWidget<UUserWidget>(GetWorld(), MaterialTextureUiClass);
```
#### 获取蓝图实例中的控件
```C++
// "Attributes"为在蓝图控件中对应的控件变量名
UCanvasPanel* canvasPanel = dynamic_cast<UCanvasPanel*>(AttrbutesWidget->GetWidgetFromName(TEXT("Attributes")));
```

### ```C++```中为按钮控件动态绑定事
```C++
//获取按钮控件
DecalEditBtn = dynamic_cast<UButton*>(AttrbutesWidget->GetWidgetFromName(TEXT("IsEditBtn")));

if (DecalEditBtn)
{
    DecalEditBtn->OnPressed.AddDynamic(this, &UAttributesui::DwonDecalEdit);
}
```

### C++中将子控件添加到父控件上（一般父控件是一个容器）
对于不同类型的父容器控件，对应不同的方法
```C++
// 如画布作为父容器控件
panel->AddChildToCanvas(childWidget);
// 如垂直框作为父容器控件
verticalBox->AddChildToVerticalBox(childWidget);
```
