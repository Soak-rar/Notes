```C++
#include <isotream>
#include <thread>

void func()
{
    cout << "hello \n";
}

int main()
{
    // 创建一个 线程对象，同时启动线程
    thread t(func);

    t.join(); // 

    return 0;
}

```

### 手撕智能指针 shared_ptr：
1. 泛型
2. 数据指针
3. 引用计数指针
4. 重写默认构造
5. 带参构造
6. 虚析构
7. 拷贝构造
8. 复制运算重载
9. 移动构造
10. 移动赋值运算符
11. 解引用
12. 指针符
13. bool运算符
14. 获得引用计数
15. 判断是否独占（即当前引用计数为 1 ）


### push_back() 和 emplace_back()的区别
#### push_back()
首先执行变量自己的构造函数，其次使用拷贝构造将变量复制到对应向量的尾部，变量再析构（注：当有移动构造时，作为参数传递给push_back时，优先使用移动构造）

#### empalce_back()
在尾部内存中直接构造

#### 比较
empalce_back优化了元素添加过程

### 移动构造
```C++
class A{
    public:
    int a;
    A(A&& ref): a(ref.a){};

}
```
在一般的构造方法中，需要申请内存空间，如果是临时变量传值，需要构造临时变量，值传递完后，释放临时变量，如函数返回栈内存的值。移动构造将临时变量的内存空间直接转移给新的变量，省去了重新开辟新空间的过程。提高效率。
A&& 为右值引用，可以使用std::move()将左值引用转为右值引用。
